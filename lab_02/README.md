# Лабораторная работа №2. Алгоритмы шифрования: Энигма

Необходимо реализовать алгоритм шифрования и дешифрования по принципу работы Энигмы.

### Конспект по теме с лекции

Энигма - электромеханическая машина. У нее есть движущиеся части, через которые проходит ток, и в нужном месте загорается лампочка. Классическая энигма состояла из 3 роторов и 1 рефлектора. Рефлектор работает по тем же принципам, что и ротор, но рефлектор не крутится, т.к. он обеспечивает возможность дешифровки на той же самой машине и замыкает цепь.

Рассмотрим пример работы алгоритма:

Допустим, у нас есть буква А, которая приходит на 1-ый ротор. В реальной физической энигме 1-ый ротор содержал пропаянные дорожки, которые связывали букву А с какой-то случайной буквой, например с буквой С. Это означало, что первый ротор шифровал букву А буквой С. Дальше буква С на 1-ом роторе связана, например, с буквой М на 2-ом роторе. На 3-ем роторе буква М была замкнута на букву I, и на последнем элементе стоит рефлектор, замыкающий букву I на букву N. И дальше машина идет в обратный ход и так далее. В итоге после прохождения через прямой ход - рефлектор - обратный ход буква А зашифрована.

Главный недостаток статистической анализируемости старых алгоритмов: нужно менять алфавит, иначе частотным анализом можно подобрать ключ. Чтобы избежать этого, как раз и существует ротор - после шифрования каждого символа происходит прокурчивание ротора, т.е. по сути смена алфавита. Каждый раз получаем новый алфавит, примерно получаем 26^3 алфавитов, если рассматривать английский алфавит.

Крутится сначала только первый ротор. Когда он сделал полный оборот, один раз прокурчивается второй ротор, и так далее. Можно провести аналогию с бытовыми счетчиками. 

Как должно происходить дешифрование? Она должна "пройти по пути" обратный ход - рефлектор - прямой ход. Нужно делать еще одну машину, делающую обратную процедуру? От этой необходимости избавляет рефлектор, который делает обратную процедуру. У него есть одно главное свойство: если на входе буква А дает букву В, то если на вход дается буква В, то он должен вернуть А (если A->B, то B->A). 

Что это нам дает? Фактически, у нас есть массив с ячейками. При прямом ходе определяющим является индекс буквы в массиве. У буквы А индекс 0. По индексу 0 будет определено значение С (если рассматривать пример). Когда мы идем в обратную сторону, мы ищем по массиву букву С и берем для нее индекс (0). Прямой ход - ищем индексы, обратный ход - значение. 

Прямой ход быстрее при данной реализации, т.к. просто обращаемся по индексу в нужную ячейку.

Если зеркально преобразуется индекс в значение, это означает, что машина работает симметрично, значит машину для шифрования можно использовать и для дешифрования. Для этого нужно ту же самую машину привести в исходную конфигурацию (роторы должны быть в тех же позициях), и можно передавать зашифрованное сообщение, в итоге получим исходное соообщение.