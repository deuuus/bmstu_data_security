# Лекция №5, 12 октября 2022 года

## Окончание прошлой лекции

Был конкурс алгоритмов, шифрующих несекретную (коммерческую) информацию. Предварительный отбор прошли 15 алгоритмов.

Требования к алгоритмам:

* Обязательные: 
  + ключи должны быть либо 128-битными, либо 192-битными, либо 256-битными;
  + блок данных, используемый при шифровании, 128-битный.

* Оценочные:
  + алгоритм должен быть криптостойким для всех известных атак на время проведения конкурса; 
  + у алгоритма должна быть ясная, простая и математически обоснованная структура, потому что это минимизирует ошибки в нем и можно проанализировать его на незадокументированные возможности; 
  + должны отсутствовать т.н. эквивалентные ключи (различающиеся ключи, которые дают одинаковый результат шифрования), потому что при криптоанализе (взломе) не нужно будет подбирать второй ключ, т.е. он уже взломан.
  + скорость шифрования должна быть высокой на аппаратных платформах разной разрядности от 8 до 64 бит;
  + поддержка параллельных вычислений;
  + минимальные требования к памяти;
  + применение алгоритма в качестве базы для построения хэш-функций и генерации псевдослучайных последовательностей.

> В 2004 году DES на распределенном кластере взламывался за 22 часа. Если будет компьютер, который за 1 секунду взломает DES, т.е. переберет все пространство 56-битных ключей, то AES со 128-битным ключом этот же компьютер будет взламывать 149 триллионов лет. 

После прохождения второго тура конкурса был выбран алгоритм-победитель: Riindael. Он был создан в католическом университете в Бельгии. После доработок этот алгоритм был опубликован к AES. Этот стандарт продолжает существовать до сих пор.

Исходный алгоритм Riindael отличается от AES тем, что он использовал вариабельность длины ключей использовал также и для блока данных, т.е. блок данных мог быть и 192-битным, и 256-битным. Заявители конкурса требовали, чтобы длина блока не варьировалась, следовательно, алгоритм был упрощен и была выпущена соответствующая редакция.

## Алгоритмы симметричного шифрования: AES (Advanced Encryption Standart)

Для обозначения длины в алгоритме AES используется т.н. слово, состоящее из 32 бит.

Все длины ключей и блока данных измеряются в словах, следовательно, длина блока данных - 4 слова, размер ключей - 4 или 6 или 8 слов. В зависимости от размера ключей, алгоритм немного трансформируется.

На длину ключа влияет количество раундов, которые применяются в данном алгоритме. В зависимости от длины ключа будет либо 10 раундов, либо 12, либо 14.

### Структура алгоритма

> Есть процедура расширения ключа, есть XOR с ключом, есть цикл, использующий комбинацию замен (SubBytes) и перестановок (ShiftRows). Есть специфическая функция перемешивания столбцов, о которой поговорим позже. Процедура дешифровки производится по аналогии с DES обратным образом.

> XOR с ключом не отличается при прямом ходе и обратном, потому что XOR обратен сам себе.

В отличие от DES, раундовые ключи могут формироваться на лету. Нет отдельной процедуры генерации раундовых ключей, не требуется формировать их заранее и хранить в памяти.

Есть раундовые ключи, функцию шифрования начинаем с XOR-a с раундовым ключом. Дальше есть цикл по количеству раундов (10, 12 или 14): выполняется замена байт по таблице S, дальше выполняется сдвиг строк матрицы 4x4, дальше если это не последний раунд, то перемешиваем столбцы, т.е. умножаем их на матрицу констант в поле Галуа, и дальше делаем XOR с раундовым ключом.

Если раунд последний, MixColumns не выполняется для того, чтобы мы могли выполнить обратную процедуру. Аналогично в DES на последнем раунде меняли местами левую и правую половины.

> XOR, замена, сдвиг, умножение на матрицу - вот и весь алгоритм.

### Основные функции

1. SubBytes: есть таблица S, которая задает замены. Например, если встретился байт со значением 63, то необходимо заметить его на соответствующую позицию в таблице, т.е. на 0. Если будет расшифровывать, то обратно: если встретим 0, то его нужно заменить на 63.

2. ShiftRows: есть матрица 4x4 (128 бит блок, и 4 слова по 4 байта). Первую строку не трогаем, вторую сдвигаем на один влево циклически, третью строку на два влево, четвертую на три. Сдвиг строчек происходит на индекс строки. Обратно - сдвиг вправо.

3. XOR с ключом: 2 блока одинаковой длины, длина раундового ключа равна длине блока данных, блок данных 128 бит.

> Если делаем XOR исходного блока данных с ключом, идет шифрование. Если делаем XOR зашифрованного блока данных с ключом, идет расшифровка.

4. Перемешивание столбцов: сводится к умножению на матрицу. Когда получим итоговую матрицу после умножения, элемент, находящийся в первой ячейке, будет являться функцией от всех элементов исходного столбца. При составлении нового блока данных после умножения на матрицу каждый элемент будет являться функцией столбца целиком (рассеивание).

После MixColumns происходит сдвиг строк: значения распространятся на всю матрицу. После следующего MixColumns каждый элемент будет влиять на каждый байт зашифрованного блока всего за 2 шага (матричное умножение + размывание сдвигами).

Таких раундов будет минимум 10.

Функция MixColumns сводится к умножению на многочлен C(x), который для нас является матрицей констант.

Главная проблема: если бы можно было просто умножить шифруемый блок данных на матрицу, то все было бы хорошо, но матричное умножение - сумма произведений, следовательно, если был байт, то когда его умножим на другой байт и сложим с 4 другими, то получим огромное число, которое с большой вероятностью не поместится в байт, а нам нужно уместить. 

Тут обычной математикой не обойтись, нужно использовать специальную математику, которая позволит остаться в пределах байта, и она должна быть обратима. После того как произведены все вычисления, при расшифровке необходимо произвести обратные вычисления. Для этого используется поле Галуа GF(8).

Главное свойство поля: в нем операции сложения и умножения заменены на XOR и умножение в виде многочленов.

Пример умножения: ```5 * 7 = 101 * 111 = (x ^ 2 + 1) * (x ^ 2 + x + 1) = x ^ 4 + x ^ 2 + x ^ 3 + x + x ^ 2 + 1 = x ^ 4 + x ^ 3 + x + 1 = 11011```

Если по итогу разрядность превысилась, делим с остатком от приводящего многочлена. В AES этот многочлен ```x ^ 4 + 1```.

### Алгоритм расширения ключа

(Написано очень сумбурно, лучше читать в других источниках)

Исходный 128-битный ключ - 4 столбца по слову. Массив раундовых ключей обозначается буквой W. Таблица RCon. 

В первые 4 слова записываем нулевой ключ. Если индекс следующего столбца кратен длине ключа (mod 4), то берется предыдущий столбец, выполняется над ним операция ShiftRow, дальше выполняем SubBytes, затем выполняем XOR с матрицей Rcon (содержит степени двойки) для вычисления очередного элемента массива W. Затем делается XOR с элементом, отстоящим на 4 позиции влево.

Все остальные элементы считаются по-другому. Если индекс не кратен 4, то берем предыдущий элемент и XOR-им с соответствующим элементом предыдущего ключа. 

Все, что было сказано, касается ситуаций, когда ключ имеет длину либо 4, либо 6 слов. Если ключ имеет длину 256 бит (8 слов), то если выполняется условие кратности, то делаем SubBytes без ShiftRows и RCon.

Есть потребность сделать 10 раундовых ключей, используя исходный ключ. Если ключ 128-битный, заполняем первые 4 элемента.

Если ключ большей длины (6 или 8 слов), то имеем возможность заполнить этим ключом не 4 слова, а вплоть до 8, и дальше уже двигаться по этому алгоритму.

> Таблицы в реальных алгоритмах устроены таким образом, что они не хранятся. Они построены на математике в поле Галуа и являются вычисляемыми на лету. 
> Этот алгоритм реализован на уровне процессоров.