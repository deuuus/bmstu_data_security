# Лекция №4, 5 октября 2022

## Случайные числа

### Какие числа считать случайными? 

Например, у нас есть две последовательности: [1, 2, 3, 7, 5] и [7, 7, 7, 7, ...]. Какую из последовательностей считать случайной? Все зависит от нашей задачи. Где-то даже повторяющиеся числа будут считаться случайностью. В какой-то задаче нужны реально случайные числа, которые будут иметь определенное распределение, а где-то нам нужны показания какого-то физического процесса, и случайная последовательность, которую мы будем получать, будет нас устраивать, даже если это будут подряд идущие повторяющиеся числа.

### Где применяются случайные числа?

Как правило, они нужны для проведения экспериментов. Если мы будем получать плохие СЧ, то мы будем иметь недостоверные результаты эксперимента. Многие сталкивались с методом Монте-Карло - методом определения площади сложной фигуры по точкам, которые проверяются на попадание в эту фигуру случайным образом. Например, если мы берем квадрат, и понимаем, сколько точек из этого квадрата попало в фигуру, значит, такая доля площади этого квадрата и есть площадь этой фигуры. Такой подход к генерации СЧ, как правило, требует равномерного распределения полученных СЧ.

### Виды случайных чисел

* реальные (настоящие) случайные числа - действительно случайные процессы порождают эти числа, источники таких числел - как правило, физические процессы в природе, на которые мы не влияем (шумы в электронике, шум звуковой карты, счетчик тактов процессора, данные счетчика Гейгера, снимки мерцающего предмета, измерение потоков воздуха, создаваемых в пространстве). 

В чистом виде эти источники используются очень редко (особенно в криптографии), потому что их очень сложно реализовать и считать, но при этом они подвержены очень грубым атакам. Если говорить про коллизии в сетевых устройствах, то на них очень легко влиять; на шумы можно влиять, добавим какой-нибудь излучатель, который будет давать нужные нам помехи. 

Второй источник получения таких чисел - пользователи (набрать большую строчку произвольных символов, подрыгать мышкой, попросить прокричать в микрофон, записать видео). Эти данные могут быть использованы для получения последовательности СЧ как в чистом виде, так и СЧ, используемые как некая функция для преобразования каких-то других данных.

* псевдослучайные числа - они образуют последовательность, которая случайна с точки зрения с точки зрения статистических законов, и эти СЧ имеют равномерное распределение. 
  
Чем отличаются реальные СЧ от псевдослучайных? ПСЧ - равномерно распределенные числа, а настоящие СЧ, которые, как правило, отражают физические процессы в природе, соответствуют нормальному закону распределения (Гауссу). Есть функции, которые преобразуют одно распределение в другое, поэтому всегда можно получить нормальное распределение из ПСЧ и наоборот.

Откуда берутся ПСЧ? Как правило, это математические законы или какие-то алгоритмы, которые создают циклическую последовательность СЧ.

Какие требования предъявляются к современным генераторам СЧ? Длина периода использования этого генератора ПСЧ должна быть больше, чем интервал, на котором она будет использоваться, т.е. мы должны давать независимую последовательность неповторяющихся чисел на всем периоде, который требуется. Если период будет короче, чем неповторяющаяся последовательность, то все хорошо, если нет, то выявляется закономерность и такие числа опасно считать случайными. Также выдвигается требование независимости последовательных значений: в идеале должно быть невозможно установить линейную закономерность чисел, идущих друг за другом. Еще одно требование --- необратимость: имея последовательность СЧ, нельзя определить, какой закон их породил, чтобы нельзя было установить эту функцию, которая лежит в основе генератора ПСЧ, и дальше использовать для взлома криптографической системы.

Как определяют, насколько хороши генерируемые ПСЧ? Самый надежный способ - тест на k-распределение случайности (спектральный тест). Пусть у нас есть СЧ, состоящее из 8 бит. Сделав какое-то отсечение в СЧ (например, возьмем первые 5 бит), и найдя все возможные варианты в нашей случайной последовательности из таких бит, которые входят в эту последовательность, то они будут иметь равномерное распределение. Если этот тест выполняется, то k = 5. Начинаем с k = 8 (в идеале все числа в последовательности должны быть распределены равномерно), потом возьмем 7-битные отсечения и тд. До какого числа сможем дойти, сохраняя равномерное распределение, значит такую глубину спектрального теста мы обеспечиваем. Т.е. в данном случае проверяется равномерность фактически на уровне структуры чисел, порождаемых генератором.

Генератор СЧ включен в набор инструкций современных процессов, т.е. уже на уровне нескольких поколений процессоров есть инструкции, позволяющие генерировать СЧ не математически, а прямо на уровне процессоров.

* Квазислучайные числа - числа, последовательность которых имеет "большую ранвомерность", чем НСЧ или ПСЧ. КСЧ имеют гарантированно равномерное распределение, более надежное, чем НСЧ или ПСЧ. Это нужно для того, чтобы иметь гарантированно равномерное распределение, т.е. для формирования более определенного поведения системы, которую мы будем "подписывать" этими СЧ.

В первую очередь нам понадобятся ПСЧ, которые можно будет использовать в криптографических функциях.

### Зоны применения генераторов ПСЧ

1. Получение последовательности СЧ в чистом виде (без изменений), как отрывной блокнот.
2. Потоковый шифровальщик (складываем по mod2 данные с СЧ), или генератор может дать начальное число для какой-то математической функции, исп. для генерации всех остальных ключей.
3. Порядковый номер в массиве чисел. Выбранное число - новый ключ.
4. Шаг в последовательности генерации других чисел, т.е. берем число не в чистом виде, а с помощью него генерируем последовательность.
5. Возведение битов некого числа, позиции которых определяются нашим СЧ.

### Алгоритмы генерации ПСЧ

1. Алгоритм Фон-Неймана (метод серединных квадратов).

Например, у нас есть 4-значное число, и 2 центральные цифры числа возводятся в квадрат. Это число дает новое СЧ, и его используем как следующее звено для генерации СЧ.

Пример: 0529 -> 1704 (52^2) -> 4900 (70^2) -> 8100 (90^2) -> 0100 (10^2) -> 0100 (10^2) -> 0100 (10^2)

Этот алгоритм очень легко исчерпать: период использования СЧ должен быть меньше, чем период генератора СЧ, тут не соблюдается требование (0100 (10^2) -> 0100 (10^2), последовательность выродилась на 6 шаге).

2. Метод перемешивания (метод сдвигов).

Берется 4-значное число и сдвигается влево на 1 символ, к нему прибавляется это же число, сдвинутое вправо на 1 символ, и так далее на каждом шаге.

3. Метод, основанный на числах Фибоначчи. 

Берутся последние цифры последовательности Фибоначчи.

4. Линейный конгруэнтный генератор. 

Вычисляет числа линейной последовательности, т.е. фактически рекурренная последовательность, которая вычисляет следующее число на базе предыдущего. 

Формула: R(n+1)=(A * R(n) + C) mod M, где M определяет размер максимального СЧ, которое мы можем получить.

Все сильно зависит от коэффициентов. Умные люди посчитали "хорошие значения": А = 430, С = 2531, М = 11979. Их хватит на лабораторных.

Есть линейные --- есть и квадратические (A * R(n)^2 + B * R(n) + C), кубические и тд конгруэнтные генераторы.

Современные генераторы СЧ очень сложные и близки к алгоритмам шифрования. Примерно такие же образования можно использовать при скорытии информации (в частности, используют следующий алгоритм).

5. Вихрь Мерсена. 
   
Есть 624 32-битных числа. Берем одно число из середины, складываем с первым числом, сдвигая его на 1 байт, и полученное значение добавляем в конец, получаем новое число. Похоже на метод перемешивания.

Фактически все получение СЧ сводится к битовым операциям.

## Симметричные алгоритмы шифрования

Это те алгоритмы, в которых и шифрующий, и расшифровывающий используют один и тот же ключ, проводимые процедуры симметричны. 

Особенности практического применения этих алгоритмов: необходимо выбрать секретный ключ (секретный во всех направлениях, и для шифрующего, и для дешифрующего) до начала организации секретного канала, т.е. у нас 2 взаимодействующие стороны должны до начала обмена встретиться и договориться о серии ключей, которые будут использоваться в рамках секретного обмена.

Нужно иметь в виду, что ключи нужно безопасно хранить, использовать и уничтожать, чтобы злоумышленник не смог использовать выброшенный ключ для прочтения старой корреспонденции. Некоторые организации создают целые книги одноразовых ключей, чтобы каждый раз менять их при новом сеансе обмена.

Все совремеенные алгоритмы симметричного шифрования используют 2 подхода к шифрованию: перестановки (линейные преобразования) и подстановки (нелинейные преобразования) (permutations, substitutions). Комбинация этих двух процедур дает хорошее запутывание шифруемых данных. Эти 2 процедуры используются не один раз, а циклически, эта комбинация циклов перестановок и подстановок называется функций Фейстеля.

### Data Encryption Standart (DES)

Впервые об этом алгоритме заговорили в 1973, когда правительство США сделало заказ на создание правительственного стандарта шифрования некритической (коммерческой) информации, здесь работает прицнип Керкгоффса - алгоритмы являются публичными. Если уходям в зону очень секретных данных, то там алгоритмы до сих пор остаются секретными. В качестве прототипа этой системы шифрования был выбран алгоритм, разработанный компанией IBM, и в 1977 он был принят как стандарт для использования в коммерческих протоколах обмена. Этот алгоритм использовался в системе межбансковских отчетов, были доверены финансы США и других стран. Он был рассчитан на 10 лет (срок эксплуатации), но он просуществовал дольше. Главный недостаток DES - короткий ключ, который можно перебрать, поэтому придумали TripleDES - ключ 192 бита, последовательно применено 3 ключа DES. Чтобы получить зашифрованное сообщение, сначала шифровали первым ключом, расшифровывали вторым ключом, и шифровали первым ключом исходные данные. Чтобы расшифровать, нужно его расшифровать 1 ключом, потом зашифровать вторым ключом, и расшифровать третьим ключом. 

Алгоритм использует ключ длинной 56 бит. Перебор такого ключа - это 7 * 10^16 операций.

Рассеяние - каждый бит шифруемого сообщения влияет на множество бит преобразованного сообщения. Алгоритм DES реализован таким образом, что *каждый* бит зашифрованного сообщения является функцией *всех* бит исходной последовательности ключа. Изменение на один бит исходных данных меняет все данные, которые будут получены в результате шифрования.

Схема алгоритма работы: открываем файл алгоритмы_DES.pdf. 

Алгоритм состоит из 4 подалгоритмов: 

1. Алгоритм преобразования ключа, т.е. есть начальный ключ, который нужно преобразовать, чтобы получить множество ключей.
2. Алгоритм Фейстеля.
3. Алгоритм шифрования.
4. Алгоритм дешифрования.

Рассмотрим по порядку эти алгоритмы.

**Алгоритм преобразования ключа**

Изначально 56-битный ключ имеет чуть большую длину - 64 бита, но каждый 8-ой бит является битом четности для контроля целостности ключа. 

На вход подается 64-битный ключ. Дальше этот ключ переставляется по табличке (ее рассмотрим дальше, пока последовательность действий). 1 бит ставится на какое-то место, 2-ой на другое, и дальше биты перемешиваются внутри себя, при этом откидываются биты четности, т.е. в результатах перестановки, отсутствуют кратные 8 биты. Получается перестановка из 56 бит.

Дальше 56 бит делим на две половины, и каждая из половин сдвигается влево на 1 или 2 бита (есть таблица, которая в зависимости от шага двигает на 1 или 2 бита). После этих сдвигов половины объединяются, и получается т.н. раундовый ключ. Раундов будет столько, сколько предписано алгоритмом, в DES'e 16 раундов. Т.е. получили начальный ключ, переставили его, разделили пополам, сдвинули, объединили, чтобы получить раундовый ключ. После этого идем за следующим ключом, и так 16 раз.

После того, как получили 16 раундовых ключей, на последнем шаге нужно сжать их до 48 бит, т.е. еще раз откидываем некоторые биты ключа. 

Благодаря правильному подбору сдвигов, раундовые ключи - все разные.

Смотрим в файл таблицы_DES. Есть начальная перестановка B, которая получает из исходного 64-битного ключа все биты, кроме контрольных (в табличке не найдем числа 8, например). Циклические сдвиги внутри 28 бит (половины): если делаем первый ключ, то у нас сдвиг на 1, второй - на 1, смотрим по таблице в общем.

В конце есть сжимающая перестановка CP, из 56 бит оставляет только 48.

**Алгоритм шифрования**

Здесь уже работаем с данными и ничего отбросить не можем, в отличие от ключей, иначе потеряется информация.

Шифрование сводится к тому, что на входе 64 бита, которые нужно зашифровать, используя 16 раундовых ключей. Сначала выполняем начальную перестановку (initial permutation, IP), она получает из 64 бит новые 64 бита (просто переставленные). Дальше мы делим их на правую и левую половины. Дальше выполняем 16 раундов с использованием ключа.

Новая левая половина получается из старой правой, а новая правая получается из старой левой и XOR из функции Фейстеля, которой на вход даем правую половину и раундовый ключ. Т.е. происходит перекрестное перемешивание, после этого выполняется конечная подстановка (IP^(-1)).

**Алгоритм дешифрования**

Смотрим на начальную перестановку: по таблице 1 бит пойдет на 58 позицию, 2-ой на 50, и тд, т.е. перемешиваем биты внутри пришедшего 64-битного блока данных.

Обратим внимание: 1 бит ушел на 58 позицию в начальной перестановке, соответственно IP^(-1) будет выполняться обратным образом, т.е. на 58 бит пойдет обратно на 1-ую позицию. Тут соблюдается правило того, что расшифровка должна быть симметрична шифрованию, так что IP и IP^(-1) - обратные друг другу перестановки.

На вход приходит 64-битное сообщение и те же раундовые ключи (ключи должны быть одинаковые, т.к. симметричное шифрование). Дальше при расшифровке выполняется начальная перестановка IP. После этого происходит разделение на половины, и цикл идет в обратную сторону: с 16 ключа к 1. Также меняем порядок применения перекрещивания к половинам: новая правая половина будет старой левой, а новая левая будет функцией от правой и XOR. И после этого опять же выполняется конечная перестановка IP^(-1). Хитрость в том, что эти перестановки обратны между собой, что позволяет при шифровании и дешифровке использовать одну и ту же последовательность преобразований.

(В схеме ошибка: конечная перестановка делается не в цикле, делается один раз).

**Алгоритм Фейстеля**

Получает на вход половину данных (32 бита) и раундовый ключ (сжимался до 48 бит). 

Делаем расширяющую перестановку для блока данных, чтобы он тоже стал 48-битным. Обратим внимание на эту перестановку: в первой строке идут числа 1, 2, 3, 4, 5, и последние два бита предыдущей строки повторяются в начале следующей строки, т.е. на каждой строке добавляем 2 бита, соответственно из 32 бит получаем 48.

Ключ и данные имеют одинаковый размер - делаем XOR, т.е. уже в данные попал ключ (данные закрыты ключом). После этого происходят замены: в DES'e есть 8 S-блоков (s - substitute), и полученные 48 бит нужно преобразовать следующим образом: разбиваем 48 бит на 8 частей. Каждой из этих 8 частей будет соответствовать один из 8 блоков.

Каждый блок - это 16 столбцов и 4 строчки, т.е. если мы используем эти 6 бит как координаты, то для получения координат строки нужно 2 бита, для получения столбца 4 бита. На пересечении видим значение. Каждый из 6 бит дают ноавые значения из блоков. 

Как используется каждый из 6 бит: первый и последний биты образуют номер строки, а 4 средних бита образуют номер столбца. Если посмотрим на блоки, значения находятся в диапазоне от 0 до 15, потому что нужно получить в итоге новое значение размером 32 бита, которое сможем использовать в функции шифрования, поэтому из 8 блоков (6-битных) получается 8 блоков, но уже 4-битных. 8 блоков по 4 бита = 32 бита. 

После того, как получим эти 32 бита, делаем завершающую перестановку по таблице P. Это и будет результат функции Фейстеля.

Функция Фейстеля - комбинация замен и перестановок. Перестановки - это E (расширяющая) и P (завершающая). Замены - это работа с S-блоками.

### Итого: как работает шифрование

Шифрование: есть 64 бита, делаем начальную перестановку, делим на 2 половины, и дальше идет 16 раундов, в каждом из которых на место старой левой половины ставим старую правую, на место правой ставим старую левую XOR с функцией Фейстеля от раундового ключа. Перекрестно меняем, выполняем конечную перестановку.

Расшифровка очень похожа, только ключи берутся в обратном порядке и наоборот обрабатываются правая и левая половинки, потому что на последнем шаге шифровки XOR выполнялся с левой частью, тут все нужно сделать наоборот: чтобы получить левую часть, нужно проксорить правую.

Фейстель прост и содержит в себе 2 операции: перестановки и замены. На вход 32 бита данных и 48 битный ключ, расширяем данные, ксорим, разбиваем на 8 частей, по табличке заменить 6 бит на 4 бита, в итоге опять переставить.

Раундовые ключи: 64 бита на входе, из которых 56 значимых. Отсекаем лишние биты, получаем две половины, их мы сдвигаем циклически в зависимости от таблицы (либо на 1, либо 2), и объединяем обратно. На каждом из шагов получаем новый раундовый ключ, который нам нужно потом сдать до 48 бит.