# Лекция №6, 19 октября 2022 года

## Алгоритмы асимметричного шифрования

> Вспомним симметричное шифрование: один и тот же ключ используется для шифрования и расшифровки. Процедуры шифрования и расшифровки - зеркальные. Главный недостаток: проблема распределения/распространения ключей (сначала нужно где-то встретиться и договориться). Решение проблемы  - использовать разные ключи для шифрования и расшифровки. Зная ключ шифрования, практически невозможно предположить ключ расшифровки. Впервые эту идею предложил Хэлман и Диффи в 1976 году.

Предложенный подход:

Есть исходное сообщение, которое мы должны зашифровать с помощью открытого ключа, т.е. ключ шифрования не секретный. В результате получаем зашифрованное сообщение:

```M: E(M, K1) -> C```

Для того, чтобы получить расшифрованное сообщение, делаем процедуру дешифровки с использованием другого ключа, и, если все хорошо, получаем исходное сообщение.

```C: D(C, K2) -> M'```

Принципы асимметричного шифрования по Хэлману и Диффи:

1. Алгоритм публичен.
2. Ключ шифрования публичен.
3. Ключ расшифровки секретен.
4. Расшифровка/получение ключа расшифровки с использованием только ключа шифрования очень трудоемко.

Благодаря этим принципам снимается проблема симметричного шифрования: можно разъезжаться в разные стороны света, а потом по публичным каналам обмениваться ключами шифрования.

### Алгоритм RSA (Riverst, Shamir, Aldman)

Алгоритм заключается в вычислении ключей, шифровании и расшифровке.

### Вычисление ключей

Берутся два простых числа P и Q. 

Вычисляется ```N = P * Q```, и это произведение называется длиной зашифрованного алфавита. 

Вычисляется функция Эйлера: ```Fi(N) = (P - 1) * (Q - 1)```. 

После этого вычисляется открытый ключ E: считается как взаимно простое число с Fi(N).

> Нет общих делителей, кроме единицы. То есть это даже не простое число (чтобы были делители), но они не имеют общих делителей с произведением.

Второй ключ D для шифрования вычисляется как решение уравнения ```(E * D) mod (Fi(N)) = 1```. 

Это обратное число к открытому ключу, но в кольце Fi(N). Логика такая же, как и в симметричных алгоритмах, но из-за того, что мы уходим в кольца, эти числа могут быть разными.

### Алгоритм шифрования

Для того, чтобы посчитать зашифрованное число, нужно сообщение возвести в степень открытого ключа и взять по модулю N:

```C = (M ^ E) mod N```

### Алгоритм расшифровки

Для того, чтобы посчитать расшифрованное сообщение, нужно зашифрованное сообщение возвести в степень закрытого ключа и взять по модулю N:

```M' = (C ^ D) mod N```

### Пояснения

Почему функция Эйлера так важна? Есть теорема Эйлера, которая говорит, что число в степени функции Эйлера равно 1.

Чтобы получить расшифрованное сообщение, подставим в зашифрованный блок то, что считается при шифровании: 

```M' = (M ^ E) ^ D = M ^ (E * D) = M ^ (1 + k * Fi(N)) = M * M ^ Fi(N) = M * 1 = M```

Примечание:

```(E * D) mod (Fi(N)) = 1 -> E * D = 1 + k * Fi(N) = 1 + k * (P - 1) * (Q - 1)```

У нас есть два простых числа, которые известны только тому, кто создает ключи. Вычисляется длина алфавита (модуль), считается функция Эйлера, вычисляются два ключа.

Для шифрования нужно знать открытую экспоненту и длину алфавита. Для расшифровки нужно знать секретный ключ и длину алфавита.

У злоумышленника, который попытается взломать шифр, есть про исходные простые числа информация только о том, какое произведение они дают, но сами числа неизвестны.

Вся безопасность алгоритма RSA базируется на сложности разложения числа на множители. Если говорить про маленькие числа, то задача несложная, но если числа большие (1000 символов, 1 КБ ключ), то задача сложная.

Проблема алгоритма: возведение в степень - дорогостоящая операция, особенно когда ключи килобайтные, поэтому этот алгоритм очень медленный.

Чтобы решить эту проблему, RSA используют в гибридной схеме: есть алгоритм с открытым ключом с асимметричным шифрованием для того, чтобы зашифровать небольшой объем информации, а дальше используется симметричная схема:

* сначала генерируем симметричный ключ, который используется обеими сторонами;
* отправка симметричного ключа получателю через асимметричное шифрование;
* на стороне получателя ключ расшифровывается;
* этот симметричный ключ используется для поточного симметричного шифрования больших объемов данных.

Симметричное шифрование используется для больших объемов данных, а асимметричное для обмена ключами. По такой схеме можно регулярно перегенерировать симметричные ключи (раз в час, например) и обмениваться ими через асимметричный канал.

### Детали алгоритма: решето Эратосфена

Алгоритм получения простых чисел. Выписываем все числа, затем вычеркиваем числа с шагом, равные числу. Оставшиеся числа - простые.

Также можно посмотреть теорему Рабина: нужно найти свидетелей простоты, если нашли - то число простое, но эта задача сложна в вычислениях, поэтому есть алгоритм Миллера-Рабина (вероятностный алгоритм).

### Детали алгоритма: возведение в степень

Ключ многокилобайтный -> возведение в степень "в лоб" переполнит любую разрядную сетку. Нас спасает то, что мы делаем математику по модулю N.

Для этого есть алгоритм быстрого возведения в степень: при возведении числа А в степень K по модулю N (```R = A ^ K mod N```), есть 3 параметра, результат возведения копим в R.

Изначально R = 1. Дальше запускаем цикл, пока не обнулится K. 

Если K - нечетное (какой бит стоит в конце ключа (1, нужно единицу учесть)), то R = (R * A) mod N. Обработали последний бит - избавляемся от него, сдвигаем степень вправо на 1 -> K = K/2, A = (A * A) mod N, т.к. степень понизилась в 2 раза. После этого возвращаемся к проверке ключа.

Независимо от четности разряда K, каждый раз степень делим на 2, а основание возводим в 2 степень. Количество операций равно количеству 1 в степени.

### Детали реализации: поиск взаимно простых чисел

Алгоритм Евклида: позволяет найти наибольший общий делитель.

Есть числа A и B, ищем для них НОД. Запускаем цикл: B = A mod B, A = B, пока НОД не станет равным 1.

Для решения второго уравнения (```(E * D) mod (Fi(N)) = 1```) используется расширенный алгоритм Евклида:

```A * X + B * Y = GCD(A, B) = 1```

Одно и то же уравнение с:

```(E * D) mod (Fi(N)) = 1 -> E * D = 1 + k * Fi(N) = 1 + k * (P - 1) * (Q - 1)```

```E * D = 1 + k * Fi(N)```

```A = E, X = D, B = -k, Y = Fi(N) ```

Нужно решить уравнение и найти D, но уравнение легко не решается. Поэтому для вычисления для коэффициента X используется расширенный алгоритм Евклида.

Берем единичную матрицу E = (10 01). Начинается обычный Евклид: R = A mod B. Пока R != 0, то E = E * (01 1 -q=A//B), B = A mod B, A = B.

В результате матрица E (1=A 0=X 0=B 1=Y) будет иметь значение X.

После вычитания могут получиться отрицательные числа, поэтому необходимо вернуться в поле.

Разложение на множители - очень трудоемкая задача, поэтому алгоритм надежный.

## Хэш-функция

Хэш-функция - некое математическое преобразование, используемое для аутентификации сообщений (проверки подлинности).

Свойства:

* применима к данным произвольной длины;
* длина хэша фиксированна, чтобы было удобно сравнивать эти данные;
* дешевизна вычислений;
* необратимость исходного сообщения по хэшу;
* если данные разные, то и хэш должен быть разным.

Хэш используется, когда проводится работа с асимметричной криптографией, которая очень медленная по сравнению с симметричной, и тяжело будет аутентифицировать (сверять) целиком все данные. Например, нужно определить, не поменялся ли образ DVD-диска или проверить в БД не произошли ли изменение.

Второе применение - когда нельзя демонстрировать исходные данные, выдается значение хэш-функции, например когда работаем с паролем. Хороший тон - хранить пароли в виде хэша.

Хэш, если он качественный, гарантированно выявляет любые изменения исходного сообщения.

### История хэш-функций

Было 2 семейства: message digest (MD, например md5) и secure hash algorithms (SHA). 

Про md5: входной блок данных 128 бит, хэш - 160 бит. Этот алгоритм, созданный в 80-ые, долгое время использовался, пока для него не была обнаружена birthday-коллизия: проводится аналогия с вероятностью, что в одном помещении находятся два человека с одинаковыми днями рождения (аунтентификатор человека в данном примере - день рождения). Сталкиваемся с аналогичной проблемой. Все проблемы хэш-функций сводятся к таким коллизиям.

Про SHA: был алгоритм sha0, который был отозван практически сразу (блок данных 512 бит, а хэш 160 бит, был предложен алгоритм, который подбирал 2 разных сообщения, для которых хэш будет идентичен). 

Такой стандарт использовать нельзя => появился sha1: блок данных 512 бит, хэш 160 бит. 

> Чем длиннее хэш, тем больше пространства аутентификаторов мы можем присвоить. Чем хэш короче, тем больше вероятность коллизии.

Современные алгоритмы (семейство sha2) используют блоки данных размером 512/1024 бит, а у хэша много версий: 256/224 или 512/384.

Сейчас используется sha3: блоки данных размером 512/1024 бит, хэш: 256/224 или 512/384.

К чему сводятся все алгоритмы хэширования? 

* Лавинный эффект (avalanche) - очень близко к рассеиванию. То, на сколько бит в хэше влияет изменение одного бита в исходном сообщении. Если при изменении 1 исходного бита меняется N, то лавинный эффект порядка N. Базируется на двух преобразованиях:
  + Конфузия - зависимость ключа и выходных данных становится нелинейной (замены).
  + Диффузия - когда создается избыточность в статистике входных данных, соответственно она размазывается по всей структуре входных данных. Следовательно, при статистическом анализе влияния входных данных на выходные скрывается структура исходного сообщения. Обеспечивается путем линейных преобразований (перемешивания, аналогия P в DES).

Комбинация конфузии и диффузии дает высокий лавинный эффект.

> Нужно убрать линейность и всех запутать: переставить биты.

В алгоритмы хэширования входит большое количество комбинаций функций XOR, OR, AND. Обычно хэш-функция очень похожа на функцию шифрования, только используются не ключи, а какие-то константы, которые являются инициализирующими на входе, и уже к ним добавляется по тем же самым принципам (через перестановки, замены) все преобразования.

Детально на хэш-функциях останавливаться не будем. Принцип похож на алгоритм генерации случайных чисел.

Md5 и sha1 уже считаются небезопасными. Используем sha2/sha3.

### Электронная подпись

При переходе из мира бумажных элементов в интернет-мир понадобился аналог собственноручной подпись. 

Свойства обычной подписи:

1. Доказывает добровольное согласие (только владелец подписи должен уметь ее поставить).
2. Подтверждение подлинность подписанта.
3. Подтверждение его авторства (действительно захотел подписать документ), неотказуемость.
4. Жесткая связь с документом (непереносимость).
5. Целостность (весь текст на одной странице, а подпись отдельно на другой - не должно быть возможности заменить один текст на другой).

Одно из первых применений электронной подписи - в 1969 был подписан договор о нераспространении ядерного оружия (пример про датчики радиации на полигонах, открытость и подлинность данных).
В 1993 году появился коммерческий вариант: DSA (digital signature algorithm). Уже появляются электронные ключи.

### Алгоритм подписания (формирования электронной подписи)

На входе есть сообщение M и алгоритм с открытым ключом: есть ключ шифрования E и ключ расшифровки D.

Почему здесь хорошо подходит асимметричная криптография? Должна быть возможность только у одного человека расшифровать, и у всех возможность зашифровать. 

Если будет наоборот, то только у одного человека будет возможность подписать, и у всех будет возможность проверить эту подпись. 

Ключ, которым будем шифровать - секретный. Ключ, которым проверяем подпись - открытый.

> Важный момент: при использовании алгоритмов шифрования с открытым ключом мы секретным ключом расшифровываем данные. Открытым ключом может кто угодно зашифровать, а получить доступ к секретной информации (расшифровать) может только владелец секретного ключа. 
> Здесь же все наоборот: принцип открытости. Зашифровать может только владелец секретного ключа (подписи). Подписать может только тот, кто владеет секретным ключом. Проверить эту подпись может кто угодно.

E и D меняются местами. Учитывая, что в алгоритмах асимметричного шифрования операции шифрования и расшифровки обратны друг другу, то это не создает проблем.

Считаем хэш-функцию: H(M). Хэш-функцию нужно посчитать потому, что если данные будут достаточно большие, то заниматься шифрованием (подписанием) большого объема данных и проверки долго. Хэш однозначно идентифицирует сообщение и вместо самого сообщения мы можем использовать хэш.

Дальше хэш шифруем с секретным ключом: ```ES = Enc(H(M), E)```. Это и будет электронная подпись (подписание).

Электронная подпись - зашифрованный хэш от сообщения.

### Алгоритм проверки подписи

Есть сообщение M, которое к нам пришло, есть подпись ES и есть **открытый** ключ расшифровки D. 

Как и при подписании, считаем хэш от исходного сообщения в надежде, что оно не поменялось: ```H(M)```.

Дальше расшифровываем подпись: ```H' = Dec(ES, D)'```. Сверяем ```H' == H```. Совпало - сообщение соответствует электронной подписи, иначе не сошлась.

### Немного терминологии

Электронная подпись - аналог собственноручной подписи, который служит для придания электронному документу юридической силы, равной бумажному документу, подписанному собственноручной подписью. 

Сейчас работу с электронной подписью регламентирует 63 ФЗ. Согласно ему ЭП - информация в электронной форме, которая присоединена к подписываемой информации, и используется для определения лца, подписавшего информацию (связь с автором).

Виды подписей:

* простая - одноразовые коды;
* усиленная - использует криптографию, специальные алгоритмы, например RSA, делится на 2 класса:
    + квалифицированные - необходимо пройти процедуру аккредитации у специальных органов;
    + неквалифицированные.

Каждый участник документооборота должен создать себе ключ, и секретный припасти у себя, а открытый отдать другим участникам.

Модели организации работы с ЭП:

* децентрализованная - каждый из участников сделал себе ключи и поделился открытым ключом со всеми участниками. Каждый сам отвечает за хранение и подтверждение ключей. Связь все со всеми. Есть проблема: если нет кого-то, кто отвечает за обмен открытыми ключами, то могут возникать ситуации, когда ключ может быть подменен по пути;
* централизованная - появился арбитр, который сертифицирует открытые ключи. Появляется независимый орган, отвечающий за связь участника и его ключа. Все, кто участвуют в документообороте, ему доверяют. Выдает сертификат с ключом и подтверждением. Таким образом, каждый может проверить подлинность ключа каждого;

Самый популярный вариант децентрализованной модели - PGP (Pretty Good Privacy). 

Централизованная модель - PKI (Public Key Infrastructure).

Орган арбитра - центр сертификации Certification Authority(CA), удостоверяющий центр (УЦ).

Что делает центр сертификации:

* пользователь создает пару ключей;
* пользователь направляет запрос в УЦ на выпуск сертификата открытого ключа;
* <<бюрократия>>;
* выпуск сертификата для конкретного пользователя, содержит открытый ключ.

Как устроен сертификат? Подписанный УЦ открытый ключ пользователя. Ключу УЦ доверяют все.

Чтобы выпускать сертификаты, есть целый стандарт X.509, содержат:

1. Версию и алгоритм создания подписи.
2. Реквизиты УЦ (чтобы можно было проверить).
3. Срок действия сертификата (в большинстве случаев 1 год).
4. Данные владельца закрытого ключа (соответствующие открытому).
5. Открытый ключ, пришедший на сертификацию.

Алгоритм подписания и проверки подписи никак не фиксирует алгоритм шифрования и алгоритм хэширования. На выбор разработчика/страны. Эта схема применима к любой схеме подписи в любой стране мира.

> Элемент структуры KPI. Может возникнуть ситуация, что выпустили сертификат, но не очень аккуратный владелец ключа где-то его потерял или его украли. На этот случай должен быть инструмент отзыва. Существует список отозванных сертификатов: Certificate Revocation List (CRL). Список ведется УЦ и публикуется в открытом источнике. Ключ проверяется на отозванность.

Задание ЛР: электронная подпись. Подписать произвольные данные и проверить их. В отличие от RSA, разрешается использовать стандартные функции шифрования и хэширования.

Жесткая связь документа с подписью обеспечивается тем, что мы не можем как-то изменить документ (перенести), чтобы не изменились данные в нем. Если изменить хоть один бит, то хэши не сойдутся. Хэш применяем ко всему документу.